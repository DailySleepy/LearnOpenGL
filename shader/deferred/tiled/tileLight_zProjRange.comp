#version 460 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer LightPosViewBuffer { vec4 lightPosView[]; };
layout(std430, binding = 1) buffer LightIndiceBuffer { int lightIndices[]; };
layout(std430, binding = 2) buffer DepthRangeBuffer { ivec2 depthProjRange[]; };
layout(std430, binding = 3) buffer DebugBuffer { vec2 debugArray[]; };

uniform mat4 invProj;
uniform int lightCount;
uniform int tileSize;
uniform int tileCountX;
uniform int tileCountY;
uniform int maxLightsPerTile;
uniform float R_max;
uniform vec2 screenSize;
uniform bool useAABBtest;

#define inf 1000000000.0
#define z_near -0.1
#define z_far -100.0

vec4 getPlane(vec3 p0, vec3 p1, vec3 p2) {
	vec3 v0 = p0 - p2;
	vec3 v1 = p1 - p2;
	vec3 normal = normalize(cross(v0, v1));
	float d = -dot(normal, p0);
	return vec4(normal, d);
}

bool AABBIntersection(vec3 center, vec3 aabbMin, vec3 aabbMax) {
	float px = clamp(center.x, aabbMin.x, aabbMax.x);
	float py = clamp(center.y, aabbMin.y, aabbMax.y);
	float pz = clamp(center.z, aabbMin.z, aabbMax.z);

	float dx = px - center.x;
	float dy = py - center.y;
	float dz = pz - center.z;

	float d2 = dx * dx + dy * dy + dz * dz;

	return d2 <= R_max * R_max;
}

void main() {
	int globalId = int(gl_GlobalInvocationID.x);
	if (globalId >= tileCountX * tileCountY) return;
	
	ivec2 tileId = ivec2(globalId % tileCountX, globalId / tileCountX);
	int tileIndex = tileId.y * tileCountX + tileId.x;
	int indexOffset = tileIndex * maxLightsPerTile;

	vec2 tileMin = tileId * tileSize / screenSize;
	vec2 tileMax = (tileId + 1) * tileSize / screenSize;
	tileMin = tileMin * 2.0 - 1.0;
	tileMax = tileMax * 2.0 - 1.0;

	float depthMin = intBitsToFloat(depthProjRange[tileIndex][0]);
	float depthMax = intBitsToFloat(depthProjRange[tileIndex][1]);
	debugArray[tileIndex] = vec2(depthMin, depthMax);
	if(depthMin > depthMax) return;

	vec3 corners[8];
	for (int i = 0; i < 4; i++) {
        vec4 cornerNDC = vec4(
            (i == 0 || i == 3) ? tileMin.x : tileMax.x,
            (i == 0 || i == 1) ? tileMin.y : tileMax.y,
            depthMin, 1.0);		// near clip plane
        vec4 cornerView = invProj * cornerNDC;
        corners[i] = cornerView.xyz / cornerView.w;

		cornerNDC.z = depthMax; // far clip plane
        cornerView = invProj * cornerNDC;
        corners[i + 4] = cornerView.xyz / cornerView.w;
    }

	vec4 frustumPlanes[4];
	for(int i = 0; i < 4; i++) {
		frustumPlanes[i] = getPlane(corners[i], corners[(i + 1) % 4], vec3(0));
	}
	
	vec3 aabbMin = vec3(inf);
	vec3 aabbMax = vec3(-inf);
	for(int i = 0; i < 8; i++) {
		aabbMin = min(aabbMin, corners[i]);
		aabbMax = max(aabbMax, corners[i]);
	}

	int lightCountInTile = 0;
	for(int i = 0; i < lightCount && lightCountInTile < maxLightsPerTile - 1; i++) {
		// plane test
		bool planeIntersection = true;
		for(int j = 0; j < 4; j++) {
			float dis = dot(lightPosView[i], frustumPlanes[j]);
			if(dis > R_max) {
				planeIntersection = false;
				break;
			}
		}
	
		if(planeIntersection) {
			// AABB test
			if(!useAABBtest || AABBIntersection(lightPosView[i].xyz, aabbMin, aabbMax)) {
				lightCountInTile++;
				lightIndices[indexOffset + lightCountInTile] = i;
			}
		}
	}
	lightIndices[indexOffset] = lightCountInTile;
}